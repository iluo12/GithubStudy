## 命名空间
**namespace关键字**
```c
namespace N1 // N1为命名空间的名称
{
// 命名空间中的内容，既可以定义变量，也可以定义函数
int a;
int Add(int left, int right)
{
return left + right;
}
}

展开关键字  using namespace N1；
访问关键字  N1::Add

:: - 作用域运算符
```
## 输入输出
```c
cin   - 流提取
cout  - 流插入
```
## 重载函数
**形参列表(参数个数 或 类型 或 顺序)必须不同**
```c
    在linux下 命名规则是
    Add(int a, int*pa)
    _Z3AddiPi
    
    Windows下的vs  命名过于复杂 不方便看
    
    c不支持重载
```
## 缺省参数
```c
    在函数定义的时候可以初始化值
    全缺省  要全部赋值
    Add(int a = 10,intb = 20,int c = 30)
    {
        ;
    }
    Add();
    add(1);
    add(1,2);
    add(1,2,3);
    
    半缺省  必须从右向左缺省  调用时从左向右给值
    Add(int a ,intb = 20,int c = 30)
    {
        ;
    }
    add(1);  这里最少给一个值 因为a没有缺省值
    add(1,2);
    add(1,2,3);
```
## 引用
```c
    给变量取别名
    int a = 10;
    int& b = a;
    int& c = b;
```

**引用做返回值**
```c
    价值：
        a.提高效率 减少拷贝
        b.修改返回值变量
    #include N 10;
    int& At(int i)
    {
        static int a(N);
        return a[i];
    }
    for(size_t i = 0;i<N;i++)
    {
        At(i) = 10+i;
    }
    加上关键字static，该变量就被定义成为一个静态全局变量
    此时`a`是静态变量 不会被销毁 而且返回值是 左值 可以被修改 反回了a[i]这个空间的别名
    ---
    当函数返回值 出了函数作用域销毁 则不能使用引用做返回值
    int& Add(int a,int b )
    {
        int ret = a+b;
        return ret;
    }
    此时 函数调用完ret会被回收，可能会造成非法访问
    ---
    当函数返回值 出了函数作用域没销毁 可以用引用返回
     - 可以看上面的静态变量
```
**引用权限**

```c
    权限方大 - 不行
    const int a = 10;
    int& b = a;
    
    权限不变 - 可以
    const int c = 20;
    consr int& d = c;
    
    权限缩小 - 可以
    int e = 30;
    const int& f = e;
    
    `注：`表达式产生的结果是 具有常属性的  所以想要引用则需要加const
    int x1 = 1, x2 = 2;
    const int& y = x1+x2; 可以
    
    包括整形提升、截断 所产生的的是 临时拷贝的整形提升、截断
    
    double d = 11.11;
    int a = d;
    a = 11 是 d 的临时拷贝 进行截断产生的
    int& i2 = d; 不可以 - 因为临时拷贝有常属性不能改变
    const int& i3 = d; 可以 用const修饰后 i3则不能改变 权限不变
    
```
**指针和引用的区别**

| Col1 | 引用(渣男) | 指针(专一) |
| --- | --- | --- |
| 意义 | 存变量的地址 | 是变量的别名 |
| 初始化 | 不一定要初始化 | 必须初始化 |
|  | 能随意指向同类型实体 | 只能引用一个实体 |
| 空值 | 有NULL指针 | 没有NULL引用 |
| 大小 | 指针大小固定 | 引用的大小是实体的大小 |
| 增加 | 指针增加是偏移一个类型的大小 | 引用增加是实体+1 |

`总结`：指针使用更为复杂 因为控制不好可能会出现野指针 空指针 ，所以没有引用安全

## extern “C” 编译连接C++与C的调用
**例如：**
    **1、C调用C++写的库(静态库、动态库)**
    **2、C++调用C写的库(静态库、动态库)**
    
## 内联函数 inline

```c
    在C中为了 减少函数调用可以使用宏
    #define ADD(x,y) ((x)+(y))
    来代替 ADD(int x, int y){return x+y;}
    
    但是宏很复杂  例如控制不好括号  容易造成错误
    有了inline 则可以代替宏
    inline void Func()
    {
        .假设编译后是10行代码
    }
```
**内联函数原理**
    可以减少函数栈帧，直接替换成代码  不建立栈帧
**内联函数使用场景**
    建议 代码长度小于10 或20行  而且经常调用的函数
    
    危害： 
    1、假设内联函数展开是10行  调用1000次 则是10*1000 = 10000行代码
    2、假设函数不展开          调用1000次 则是10+1000 = 1010行代码
**内联函数结论**
    短小，频繁调用的函数建议定义成inline
    
## auto 自动填写类型

```c
    int a = 0;
    auto b = a;
    auto c = 'c';
    auto d = 1.1;
```