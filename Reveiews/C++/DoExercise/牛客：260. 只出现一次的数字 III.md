# 牛客：260. 只出现一次的数字 III

[牛客网：260. 只出现一次的数字 III](https://leetcode.cn/problems/single-number-iii/)

```c++
class Solution {
public:
    vector<int> singleNumber(vector<int>& nums) {
        //当只有一个，出现一次的数，全员异或，则能则到这个数
        //因为异或的特性是，两个相同的数异或结果为0；
        //相同为0，相异为1
        //任何数异或0，结果不变，所以xor初始值给0；
        //我们先异或
        int xornum = 0;
        for (int e : nums)
        {
            xornum ^= e;
        }


        //得到的结果肯定是，这两个不相同的数字异或的结果，因为其他数都被抵消了
        //此时进行分组，如何分组？
        //将两个数分到不同的组，然后进行异或
        //因为有了上面的xor，我们知道 如果这两个数的某一位二进制位为1，那么说明这一位可以区分两个这两个数。
        //例如 5 和 8 异或   
        //      0000 0110 - 6
        //      0000 0100 - 4
        //异或结果为
        //      0000 0010 - 2(res)    
        //则找到这一位，然后用这个 结果(0000 0010)进行全员与
        //与的特性：形同为1，相异为0；或全1为1，有0为0
        //例如 在 3 3 4 4 6 4中找 6 4
        //  0000 0010 - res     0000 0010 - res
        //  0000 0011 - 3       0000 0100 - 4
        //与结果   ↓                    ↓
        //  0000 0010 - 2       0000 0000 - 0
        //  结果不为0            结果为0    
        //此时两个3和两个4，与完后可以用为0和不为0区分，5和8同理
        //  0000 0010 - res     0000 0010 - res
        //  0000 0110 - 6       0000 0100 - 4
        //与结果   ↓                    ↓
        //  0000 0010 - 2       0000 0000 - 0
        //  结果不为0                结果为0 
        //此时6和4也被分开了
        //如何得到 res？
        //在很多题解中看到 x & -x 则的到了最后一位1，其他位都0；
        //x & -x == x & (~x + 1)
        //这里你需要了解 -x  ==  ~x + 1
        //这个计算方法可以的得到xor中最后一位为1的数字
        //当然了，用xor移位然后&1也可以找到 最后一位为1的数字
        //只要找到xor中的某一位为1就可以

        //为了防止溢出，判断xornum 是否等于INT_MIN (暂时我还没看懂)
        int res = (xornum == INT_MIN ? xornum : xornum & (-xornum));
        int n1 = 0, n2 = 0;
        for (int e : nums)
        {
            if (res & e)
                n1 ^= e;
            else
                n2 ^= e;
        }
        return { n1,n2 };
};
```

